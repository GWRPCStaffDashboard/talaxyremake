
const SessionController = class {
    constructor( sessionIdleTimeoutWarningPeriodInMinutes, loginTime, $BaseTimerHost ) {

        let self = this;
        self.FullLogoutTimer = null;

        self.SessionAbsoluteStart = moment( loginTime );
        self.FullTimeoutInHours = 12;
        self.IdleTimeoutInMinutes = 60;
        self.WarningPeriodInMinutes = sessionIdleTimeoutWarningPeriodInMinutes;
        self.CircleTimerInterval = 60000;

        if ( sessionIdleTimeoutWarningPeriodInMinutes == -1 ) {
            self.FullTimeoutInHours = 12;
            self.IdleTimeoutInMinutes = 720;
            self.WarningPeriodInMinutes = sessionIdleTimeoutWarningPeriodInMinutes;
            self.CircleTimerInterval = 60000;
        }

        self.CountDown = {};
        self.CountDown.Message = "Countdown timer hit zero";
        self.CountDown.UpdateScreenTimer = null;
        self.CountDown.Value = 0;

        self.ActivityNotedInTheLast5Minutes = false;
        self.sessionIdleTimeoutWarningTimerRestarted = null;

        if ( sessionIdleTimeoutWarningPeriodInMinutes == -1 ) {
            self.ActivityReporter = setInterval( function () {

                var img = new Image( 1, 1 );
                img.src = '/!Controls/SessionExtend.ashx?op=sessionreset&data=' + encodeURIComponent( moment(new Date()) );

            }, 5 * 60 * 1000 );

        } else {
            self.ActivityReporter = setInterval( function () {

                if ( self.ActivityNotedInTheLast5Minutes ) {
                    console.log( "Activity noted" );
                    var img = new Image( 1, 1 );
                    img.src = '/!Controls/SessionExtend.ashx?op=sessionreset&data=' + encodeURIComponent( moment(new Date()) );
                } else {
                    console.log( "No activity noted" );
                }
                self.ActivityNotedInTheLast5Minutes = false;

            }, 5 * 60 * 1000 );
        }




        let baseTimer = `
                                <div class="base-timer position-absolute " style='top:0px;left:0px; width: 80px; height:80px;'>
                                  <svg class="base-timer__svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"  style="transform: scaleX(-1);">
                                    <g class="base-timer__circle" style="fill:none; stroke:#000;">
                                      <circle class="base-timer__path-elapsed" cx="50" cy="50" r="45"  style='stroke-width:7px; stroke:#ffffff50;'/>
                                      <path
                                        id="base-timer-path-remaining"
                                        stroke-dasharray="283"
                                        class="base-timer__path-remaining green"
                                        style='stroke-width:7px; stroke-linecap:round; transform:rotate(90deg);  transform-origin:center; transition:1s linear all; stroke: #40404050;'
                                        d="
                                          M 50, 50
                                          m -45, 0
                                          a 45,45 0 1,0 90,0
                                          a 45,45 0 1,0 -90,0
                                        "
                                      ></path>
                                    </g>
                                  </svg>
                                  <span>
                                    <!-- Remaining time label -->
                                  </span>
                                </div>
                                `;

        $BaseTimerHost.append( baseTimer );

        let $btpr = $( "#base-timer-path-remaining" )
        let circleTimer = setInterval( function () {

            let howLongLeftInSeconds = self.HowLongLeft().UntilSoonestLogout;

            //console.log( "tick " + howLongLeftInSeconds  + " / " + ( SessionControl.IdleTimeoutInMinutes * 60 ) );


            $btpr.attr( "stroke-dasharray", ( 283 * howLongLeftInSeconds / ( self.IdleTimeoutInMinutes * 60 ) ).toFixed( 0 ) + " 283" );


            if ( howLongLeftInSeconds < 3 * 60 ) { //even if the warning popup is 1 minute before, always show the last 3 as red
                $btpr.css( "stroke", "#ff404050" )
            } else {
                $btpr.css( "stroke", "#40404050" )
            }


        }, self.CircleTimerInterval );

        self.StartWarningTimer();



        //If another tab tells us the user is active
        CrossTabUtilities.OnBroadcastMessage( "ResetSessionWarningTimer", function ( eventDataString ) {

            //some other tab is telling this one to reset its timer
            self.YesExtend( true );

            //If we were showing the question right now, hide it too
            $( "#sessionModal" ).modal( "hide" );

        } );


        CrossTabUtilities.OnBroadcastMessage( "NotifyExport", function ( eventDataString ) {

            //some other tab is telling this one to NotifyExport  
            self.NotifyExport( true );

        } );

        //If soeone says logout is ok on another tab, we're ok too.
        CrossTabUtilities.OnBroadcastMessage( "User declined session extension", function ( eventDataString ) {

            self.RedirectToSignOutPage( "User declined session extension" );
        } );



        //As we are a new page loading, the user is still active, this counts as new activity, so any other tabs need their warning resert
        CrossTabUtilities.BroadcastMessageToAllTabs( "ResetSessionWarningTimer", "" );



    }

    NotifyExport( anticycle ) {

        let self = this;
        $( "#sessionModal" ).modal( "hide" );
        self.SessionAbsoluteStart = moment();
        self.ProcessActivity();
        self.YesExtend( true );

        //Not requried as YesExtend will perturb the session
        //$$PageMethod( "RPT_CheckTransfer", [ guid() ], null, "", "" );

        var img = new Image( 1, 1 );
        img.src = '/!Controls/SessionExtend.ashx?op=sessionreset&data=' + encodeURIComponent( moment(new Date()) );

        if ( anticycle ) {

        } else {
            CrossTabUtilities.BroadcastMessageToAllTabs( "NotifyExport", "" );
        }

    }

    ProcessActivity( e ) {
        if ( e ) {
            if ( ( e.type == 'mousedown' ) && ( ( e.target == $( "#user-dropdown" )[ 0 ] ) || ( $( "#user-dropdown" ).children().find( $( e.target ) ).length > 0 ) ) ) {
                //don;t upset the timers by seeing how long is left on them
                return;
            }
        }
        clearInterval( this.CountDown.UpdateScreenTimer );
        clearTimeout( this.FullLogoutTimer );
        clearTimeout( this.sessionIdleTimeoutWarningTimer );

        this.StartWarningTimer();

        //All the while they are typing, the session on the server is getting older and older
        this.ActivityNotedInTheLast5Minutes = true;

        //Tell other tabs we're typing
        CrossTabUtilities.BroadcastMessageToAllTabs( "ResetSessionWarningTimer", "" );
    }

    StartWarningTimer() {
        let self = this;
        this.sessionIdleTimeoutWarningTimerRestarted = performance.now();

        if ( !typeof isPwa === "undefined" && isPwa() ) {
            //running as app so fire a stay-logged-in
            self.YesExtend();
            return;
        }

        let soonestLogoutCandidateAInTicks = ( this.IdleTimeoutInMinutes - this.WarningPeriodInMinutes ) * 60 * 1000;
        let soonestLogoutCandidateBInTicks = moment( this.SessionAbsoluteStart ).add( this.FullTimeoutInHours, "hours" ).diff( moment(), "ticks" ) - ( this.WarningPeriodInMinutes * 60 * 1000 );

        let warningDelay = Math.min( soonestLogoutCandidateAInTicks, soonestLogoutCandidateBInTicks );
        if ( soonestLogoutCandidateBInTicks < -this.WarningPeriodInMinutes * 60 * 1000 ) {
            this.CountDown.Message = "Absolute session limit hit.";
            this.RedirectToSignOutPage( this.CountDown.Message );
        } else if ( soonestLogoutCandidateBInTicks < 0 ) {
            //We've gone past the last oppertunity to extend, theres nothing to do now but what the session time out.      
        } else {

            this.sessionIdleTimeoutWarningTimer = setTimeout( function () { self.SessionWarning() }, warningDelay );
        }


    }
    SessionWarning() {
        let self = this;


        //Start the timer which is ging to actually log out after the warning period
        let message = self.CountDown.Message;
        let periodInTicks = self.WarningPeriodInMinutes * 60 * 1000;


        $( "#sessionModal" ).modal( "show" );

        self.FullLogoutTimer = setTimeout( function () { self.RedirectToSignOutPage( message ) }, periodInTicks );

        self.CountDown.Value = self.WarningPeriodInMinutes * 60 + 1;
        self.UpdateCountdown();



        self.CountDown.UpdateScreenTimer = setInterval( function () {

            self.UpdateCountdown();

        }, 1000 );
    }

    UpdateCountdown() {
        let self = this;
        var o = self.CountDown.Value--;

        if ( o <= 0 ) {
            //The full log out timer should be kicking in about now.
            clearInterval( self.CountDown.UpdateScreenTimer );
            self.CountDown.UpdateScreenTimer = null;
        }



        var mm = Math.floor( ( o % 3600 ) / 60 );
        var ss = Math.floor( o % 60 );


        if ( ss < 0 ) ss = 0;
        if ( mm < 1 ) {
            $( "#minutesForExpiry" ).text( "" + ss + " seconds" ); // minutes 
        } else {
            if ( mm == 1 ) {
                $( "#minutesForExpiry" ).text( "" + mm + " minute" ); // minutes
            } else {
                $( "#minutesForExpiry" ).text( "" + mm + " minutes" ); // minutes
            }

        }
    }




    RedirectToSignOutPage( Reason ) {

        let poster = new PagePoster( "_self", "/LoggingOut" );
        poster.AddParameter( "reason", Reason );
        poster.Post();


    }



    YesExtend( anticycle ) {

        clearInterval( this.CountDown.UpdateScreenTimer );
        clearTimeout( this.FullLogoutTimer );
        clearTimeout( this.sessionIdleTimeoutWarningTimer );

        this.StartWarningTimer()

        if ( anticycle ) {
            //we're doing this because of a broadcast
        } else {
            CrossTabUtilities.BroadcastMessageToAllTabs( "ResetSessionWarningTimer", "" );
        }

    }

    NoExtend() {
        clearInterval( this.CountDown.UpdateScreenTimer );

        CrossTabUtilities.BroadcastMessageToAllTabs( "User declined session extension", "" );
        RedirectToSignOutPage( "User declined session extension" );

    }



    HowLongLeft() {

        let returnValue = {}
        returnValue.UntilIdleWarning = "";
        returnValue.UntilIdleLogout = "";
        returnValue.UntilAbsoluteWarning = "";
        returnValue.UntilAbsoluteLogout = "";
        returnValue.UntilSoonestLogout = 0;
        returnValue.Table = "";

        let hh = 0;
        let mm = 0;
        let ss = 0;

        let soonestLogoutCandidateAInTicks = ( this.IdleTimeoutInMinutes - this.WarningPeriodInMinutes ) * 60 * 1000; //how many ticks until the warning
        let soonestLogoutCandidateBInTicks = ( moment( this.SessionAbsoluteStart ).add( this.FullTimeoutInHours, "hours" ).diff( moment(), "ticks" ) ) - ( this.WarningPeriodInMinutes * 60 * 1000 ); //how many ticks until the enforced logout warning

        let result = "";
        {
            let timeLeftInTicks = soonestLogoutCandidateAInTicks - ( performance.now() - this.sessionIdleTimeoutWarningTimerRestarted );

            let ticksInSecs = timeLeftInTicks / 1000;
            mm = Math.floor( ( ticksInSecs % 3600 ) / 60 );
            ss = Math.floor( ticksInSecs % 60 );

            returnValue.UntilIdleWarning = ( mm > 0 ? mm + "m " : "" ) + ss + "s";

            ticksInSecs += 60 * this.WarningPeriodInMinutes;
            returnValue.UntilSoonestLogout = ticksInSecs;
            mm = Math.floor( ( ticksInSecs % 3600 ) / 60 );
            ss = Math.floor( ticksInSecs % 60 );

            returnValue.UntilIdleLogout = ( mm > 0 ? mm + "m " : "" ) + ss + "s";

        }


        {
            let timeLeftInTicks = soonestLogoutCandidateBInTicks - ( performance.now() - this.sessionIdleTimeoutWarningTimerRestarted );

            let ticksInSecs = timeLeftInTicks / 1000;

            hh = Math.floor( ticksInSecs / 3600 );
            mm = Math.floor( ( ticksInSecs % 3600 ) / 60 );
            ss = Math.floor( ticksInSecs % 60 );


            returnValue.UntilAbsoluteWarning = ( hh > 0 ? hh + "h " : "" ) + ( hh * 60 + mm > 0 ? mm + "m " : "" ) + ss + "s";




            ticksInSecs += 60 * this.WarningPeriodInMinutes;
            if ( ticksInSecs < returnValue.UntilSoonestLogout ) {
                returnValue.UntilSoonestLogout = ticksInSecs;
            }

            hh = Math.floor( ticksInSecs / 3600 );
            mm = Math.floor( ( ticksInSecs % 3600 ) / 60 );
            ss = Math.floor( ticksInSecs % 60 );

            returnValue.UntilAbsoluteLogout = ( hh > 0 ? hh + ":h " : "" ) + ( hh * 60 + mm > 0 ? mm + "m " : "" ) + ss + "s";


        }


        returnValue.Table = `<table class='w-100 -table'> 
                        <tr ><td class='ps-5'>Until idle warning</td><td class='text-end pe-2'>${ returnValue.UntilIdleWarning }</td></tr>
                        <tr><td class='ps-5'>Until idle timeout</td><td class='text-end pe-2'>${ returnValue.UntilIdleLogout }</td></tr>
                        <tr><td class='ps-5'>Until absolute warning</td><td class='text-end pe-2'>${ returnValue.UntilAbsoluteWarning }</td></tr>
                        <tr><td class='ps-5'>Until absolute timeout</td><td class='text-end pe-2'>${ returnValue.UntilAbsoluteLogout }</td></tr>
                </table>`;


        return returnValue;


    }

}



